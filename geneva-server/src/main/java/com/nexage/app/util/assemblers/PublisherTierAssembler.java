package com.nexage.app.util.assemblers;

import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.nexage.admin.core.enums.TierType;
import com.nexage.admin.core.model.Tag;
import com.nexage.admin.core.model.Tier;
import com.nexage.admin.core.sparta.jpa.model.TagPosition;
import com.nexage.app.dto.Status;
import com.nexage.app.dto.publisher.PublisherPositionDTO;
import com.nexage.app.dto.publisher.PublisherTagDTO;
import com.nexage.app.dto.publisher.PublisherTagWeightDTO;
import com.nexage.app.dto.publisher.PublisherTierDTO;
import com.nexage.app.error.ServerErrorCodes;
import com.nexage.app.util.assemblers.context.PublisherTierContext;
import com.ssp.geneva.common.error.exception.GenevaValidationException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.springframework.stereotype.Component;

@Component
public class PublisherTierAssembler
    extends Assembler<PublisherTierDTO, Tier, PublisherTierContext> {

  public static final Set<String> DEFAULT_FIELDS =
      Set.of(
          "pid",
          "version",
          "name",
          "level",
          "position",
          "tags",
          "weights",
          "orderStrategy",
          "autogenerated",
          "tierType");

  public PublisherTierDTO make(final PublisherTierContext context, final Tier tier) {
    return make(context, tier, DEFAULT_FIELDS);
  }

  public PublisherTierDTO make(
      final PublisherTierContext context, final Tier tier, final Set<String> fields) {
    PublisherTierDTO.Builder publisherTierBuilder = PublisherTierDTO.newBuilder();

    Set<String> fieldsToMap = (fields != null) ? fields : DEFAULT_FIELDS;

    for (String field : fieldsToMap) {
      switch (field) {
        case "pid":
          publisherTierBuilder.withPid(tier.getPid());
          break;
        case "version":
          publisherTierBuilder.withVersion(tier.getVersion());
          break;
        case "level":
          publisherTierBuilder.withLevel(tier.getLevel());
          break;
        case "position":
          if (tier.getPosition().getPid() != null) {
            publisherTierBuilder.withPosition(
                PublisherPositionDTO.builder().withPid(tier.getPosition().getPid()).build());
          }
          break;
        case "tags":
          for (Tag tag : tier.getTags()) {
            if (tag.isPublisherSelfServeTag()
                && tag.getPosition().getPid().equals(tier.getPosition().getPid())) {
              if (Status.ACTIVE.name().equals(tag.getStatus().name())
                  || Status.INACTIVE.name().equals(tag.getStatus().name())) {
                publisherTierBuilder.withTag(
                    PublisherTagDTO.newBuilder()
                        .withPid(tag.getPid())
                        .withStatus(Status.valueOf(tag.getStatus().name()))
                        .build());
              }
            }
          }
          break;
        case "weights":
          if (tier.getWeight() != null) {
            for (Entry<Long, Double> entry : tier.getWeight().entrySet()) {
              PublisherTagWeightDTO publisherTagWeight =
                  PublisherTagWeightDTO.newBuilder()
                      .withTag(PublisherTagDTO.newBuilder().withPid(entry.getKey()).build())
                      .withWeight(entry.getValue())
                      .build();
              publisherTierBuilder.withTagWeight(publisherTagWeight);
            }
          }
          break;
        case "orderStrategy":
          publisherTierBuilder.withOrderStrategy(
              PublisherTierDTO.OrderStrategy.valueOf(tier.getOrderStrategy().name()));
          break;
        case "autogenerated":
          publisherTierBuilder.withIsAutogenerated(tier.isAutogenerated());
          break;
        case "tierType":
          publisherTierBuilder.withTierType(tier.getTierType());
          break;
        default:
      }
    }

    return publisherTierBuilder.build();
  }

  public Tier apply(
      final PublisherTierContext context, Tier tier, final PublisherTierDTO publisherTier) {
    // use the specified level, otherwise put the tier at the end
    tier.setLevel(publisherTier.getLevel() != null ? publisherTier.getLevel() : Integer.MAX_VALUE);

    tier.setTierType(
        publisherTier.getTierType() != null ? publisherTier.getTierType() : TierType.WATERFALL);

    tier.setPosition(context.getPosition());

    if (publisherTier.getOrderStrategy() != null) {
      tier.setOrderStrategy(Tier.OrderStrategy.valueOf(publisherTier.getOrderStrategy().name()));
    }

    if (tier.getPid() == null) {
      tier.setAutogenerated(
          publisherTier.isAutogenerated() == null ? false : publisherTier.isAutogenerated());
    }

    // the position to be used for any tags put into this tier
    TagPosition tagPosition = new TagPosition();
    tagPosition.setPid(context.getPosition().getPid());

    Set<Tag> tags = context.getSite().getTags();

    Map<Long, Tag> tagMap = Maps.uniqueIndex(tags, from -> from.getPid());

    // get the tags and the tiers they are deployed to
    Map<Long, Set<Long>> currentTagTiers = getCurrentTagTierDeployments(context);

    List<Tag> tempNexageTags = new ArrayList<>();

    for (Tag tag : tier.getTags()) {
      if (tag.getPosition() == null || !tag.getPosition().getPid().equals(tier.getPositionPid())) {
        tempNexageTags.add(tag);
      }
    }

    // update the tags associated with this tier
    tier.setTags(new ArrayList<>());
    if (publisherTier.getTags() != null) {
      for (PublisherTagDTO publisherTag : publisherTier.getTags()) {

        Tag tag = tagMap.get(publisherTag.getPid());
        if (tag == null) {
          throw new GenevaValidationException(ServerErrorCodes.SERVER_TIER_INVALID_TAG_SPECIFIED);
        }

        if (tag.getPosition() != null && !tag.getPosition().getPid().equals(tagPosition.getPid())) {
          throw new GenevaValidationException(
              ServerErrorCodes.SERVER_TAG_ALREADY_ASSIGNED_POSITION);
        }
        tag.setPosition(tagPosition);

        // check to see if this tag was deployed prior to this
        if (currentTagTiers.containsKey(tag.getPid())) {
          // only change revenue flag if not previously set (this shouldn't happen)
          if (tag.getImportRevenueFlag() == null) {
            tag.setImportRevenueFlag(true);
          }
        } else {
          if (tag.getImportRevenueFlag() == null || !tag.getImportRevenueFlag()) {
            tag.setImportRevenueFlag(true);
          }
        }

        tier.addTag(tag);
      }
    }

    for (Tag t : tempNexageTags) {
      tier.addTag(t);
    }

    // update the tag weights (if defined) for this tier
    tier.clearWeights();
    if (tier.getOrderStrategy().equals(Tier.OrderStrategy.Static)
        && publisherTier.getWeights() != null) {
      Double totalWeight = 0.0D;
      for (PublisherTagWeightDTO tagWeight : publisherTier.getWeights()) {
        Tag tag = tagMap.get(tagWeight.getTag().getPid());
        if (tag == null) {
          throw new GenevaValidationException(ServerErrorCodes.SERVER_TIER_INVALID_TAG_SPECIFIED);
        }
        tier.addTagWeight(tagWeight.getTag().getPid(), tagWeight.getWeight());
        totalWeight += tagWeight.getWeight();
      }

      if (!totalWeight.equals(1D)) {
        throw new GenevaValidationException(ServerErrorCodes.SERVER_TIER_INVALID_STATIC_WEIGHTS);
      }
    }

    return tier;
  }

  private Map<Long, Set<Long>> getCurrentTagTierDeployments(PublisherTierContext context) {
    Map<Long, Set<Long>> currentTagTiers = Maps.newHashMap();
    for (Tier tr : context.getPosition().getTiers()) {
      for (Tag tg : tr.getTags()) {
        if (currentTagTiers.containsKey(tg.getPid())) {
          currentTagTiers.get(tg.getPid()).add((long) tr.getLevel());
        } else {
          currentTagTiers.put(tg.getPid(), Sets.newHashSet(Long.valueOf(tr.getLevel())));
        }
      }
    }
    return currentTagTiers;
  }
}
