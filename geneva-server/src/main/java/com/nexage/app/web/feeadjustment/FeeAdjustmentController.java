package com.nexage.app.web.feeadjustment;

import static org.springframework.http.MediaType.ALL_VALUE;
import static org.springframework.http.MediaType.APPLICATION_JSON_VALUE;

import com.codahale.metrics.annotation.ExceptionMetered;
import com.codahale.metrics.annotation.Timed;
import com.nexage.admin.core.model.feeadjustment.FeeAdjustment;
import com.nexage.admin.core.validator.CreateGroup;
import com.nexage.admin.core.validator.UpdateGroup;
import com.nexage.app.dto.feeadjustment.FeeAdjustmentDTO;
import com.nexage.app.error.ServerErrorCodes;
import com.nexage.app.services.FeeAdjustmentService;
import com.ssp.geneva.common.error.exception.GenevaValidationException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import java.util.Set;
import javax.validation.groups.Default;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@Tag(name = "/v1/fee-adjustments")
@RestController
@RequestMapping(value = "/v1/fee-adjustments")
public class FeeAdjustmentController {

  private final FeeAdjustmentService feeAdjustmentService;

  public FeeAdjustmentController(FeeAdjustmentService feeAdjustmentService) {
    this.feeAdjustmentService = feeAdjustmentService;
  }

  /**
   * POST Method: Create a {@link FeeAdjustment} persistent entity using a {@link FeeAdjustmentDTO}
   * as a template. Validation requires that autogenerated fields be null in this request (e.g. pid
   * = null and version = null).
   *
   * @param feeAdjustmentDTO The {@link FeeAdjustmentDTO} to use as a template.
   * @return {@link ResponseEntity} of type {@link FeeAdjustmentDTO} with autogenerated fields
   *     initialized.
   */
  @Operation(summary = "Create a fee adjustment entity.")
  @ApiResponse(content = @Content(schema = @Schema(implementation = FeeAdjustmentDTO.class)))
  @Timed
  @ExceptionMetered
  @PostMapping(consumes = APPLICATION_JSON_VALUE, produces = APPLICATION_JSON_VALUE)
  public ResponseEntity<FeeAdjustmentDTO> createFeeAdjustment(
      @RequestBody @Validated(value = {Default.class, CreateGroup.class})
          FeeAdjustmentDTO feeAdjustmentDTO) {
    return ResponseEntity.status(HttpStatus.CREATED)
        .body(feeAdjustmentService.create(feeAdjustmentDTO));
  }

  /**
   * PUT Method: Update an existing {@link FeeAdjustment} entity using a {@link FeeAdjustmentDTO} as
   * a template. Validation requires that the pid on the request DTO match the pid in the path of
   * the request.
   *
   * @param pid The pid of the {@link FeeAdjustment} entity to update.
   * @param feeAdjustmentDTO The {@link FeeAdjustmentDTO} to use as a template.
   * @return {@link ResponseEntity} of type {@link FeeAdjustmentDTO}.
   */
  @Operation(summary = "Update the fee adjustment entity.")
  @ApiResponse(content = @Content(schema = @Schema(implementation = FeeAdjustmentDTO.class)))
  @Timed
  @ExceptionMetered
  @PutMapping(
      value = "/{pid}",
      consumes = APPLICATION_JSON_VALUE,
      produces = APPLICATION_JSON_VALUE)
  public ResponseEntity<FeeAdjustmentDTO> updateFeeAdjustment(
      @PathVariable(value = "pid") Long pid,
      @RequestBody @Validated(value = {Default.class, UpdateGroup.class})
          FeeAdjustmentDTO feeAdjustmentDTO) {
    if (!pid.equals(feeAdjustmentDTO.getPid())) {
      throw new GenevaValidationException(ServerErrorCodes.SERVER_PIDS_MISMATCH);
    }

    return ResponseEntity.ok(feeAdjustmentService.update(feeAdjustmentDTO));
  }

  /**
   * GET Method: Retrieve an existing {@link FeeAdjustment} entity as a {@link FeeAdjustmentDTO}
   * object.
   *
   * @param pid The pid of the {@link FeeAdjustment} entity to retrieve.
   * @return {@link ResponseEntity} of type {@link FeeAdjustmentDTO}.
   */
  @Operation(summary = "Retrieve a fee adjustment entity.")
  @ApiResponse(content = @Content(schema = @Schema(implementation = FeeAdjustmentDTO.class)))
  @Timed
  @ExceptionMetered
  @GetMapping(value = "/{pid}", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  public ResponseEntity<FeeAdjustmentDTO> getFeeAdjustment(@PathVariable(value = "pid") Long pid) {
    return ResponseEntity.ok(feeAdjustmentService.get(pid));
  }

  /**
   * GET Method: Retrieve a page of {@link FeeAdjustmentDTO} available objects based on the
   * query/page parameters. Note that this service is intended to provide a mechanism to discover
   * any available {@link FeeAdjustment} entities which are available.
   *
   * @param qf A unique {@link Set} of fields.
   * @param qt The term to be found.
   * @param enabled The value to match on the "enabled" field.
   * @param pageable The {@link Pageable} pagination parameters.
   * @return {@link Page} of {@link FeeAdjustmentDTO} objects based on the query/page parameters.
   */
  @Timed
  @ExceptionMetered
  @GetMapping(produces = APPLICATION_JSON_VALUE)
  public ResponseEntity<Page<FeeAdjustmentDTO>> getAllFeeAdjustments(
      @Parameter(name = "A set of fee adjustment fields to search for the query term.")
          @RequestParam(value = "qf", required = false)
          Set<String> qf,
      @Parameter(name = "A query search term.") @RequestParam(value = "qt", required = false)
          String qt,
      @Parameter(name = "A query for the enabled field.")
          @RequestParam(value = "enabled", required = false)
          Boolean enabled,
      @PageableDefault(sort = "pid", size = 10) Pageable pageable) {
    return ResponseEntity.ok(feeAdjustmentService.getAll(qf, qt, enabled, pageable));
  }

  /**
   * DELETE Method: Delete an existing {@link FeeAdjustment} entity with the specified pid.
   *
   * @param pid The pid of the {@link FeeAdjustment} entity to delete.
   * @return {@link ResponseEntity} of type {@link FeeAdjustmentDTO}.
   */
  @Timed
  @ExceptionMetered
  @DeleteMapping(value = "/{pid}", consumes = ALL_VALUE, produces = APPLICATION_JSON_VALUE)
  public ResponseEntity<FeeAdjustmentDTO> deleteFeeAdjustment(
      @PathVariable(value = "pid") Long pid) {
    return ResponseEntity.ok(feeAdjustmentService.delete(pid));
  }
}
