package com.nexage.admin.core.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.nexage.admin.core.enums.TierType;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.persistence.CascadeType;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.MapKeyColumn;
import javax.persistence.OrderColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.Formula;
import org.hibernate.envers.AuditJoinTable;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Entity
@Table(name = "tier")
@Audited
@Getter
@Setter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class Tier implements Serializable {

  private static final long serialVersionUID = 1L;

  private static final Logger logger = LoggerFactory.getLogger(Tier.class);

  private static final String WEIGHTS_MAP_KEY_PREFIX = "_"; // leading underscore

  @Id @GeneratedValue @EqualsAndHashCode.Include private Long pid;

  @Column(name = "position_pid", insertable = false, updatable = false)
  @NotAudited
  @Setter(AccessLevel.NONE)
  @EqualsAndHashCode.Include
  private Long positionPid;

  @ManyToOne
  @JoinColumn(name = "position_pid", referencedColumnName = "pid")
  @NotNull
  @JsonIgnore
  @JsonBackReference
  @EqualsAndHashCode.Include
  private Position position;

  @Formula("(SELECT p.name FROM position p WHERE p.pid = position_pid)")
  @NotAudited
  private String positionName;

  @Column @EqualsAndHashCode.Include private int level;

  public enum OrderStrategy {
    Dynamic,
    Static;
  }

  @Column(name = "order_strategy", nullable = false)
  @NotNull
  @Enumerated(EnumType.STRING)
  @EqualsAndHashCode.Include
  OrderStrategy orderStrategy;

  @Version
  @Column(name = "VERSION", nullable = false)
  private Integer version;

  @ManyToMany(fetch = FetchType.EAGER, cascade = CascadeType.REFRESH)
  @JoinTable(
      name = "tier_tag",
      joinColumns = @JoinColumn(name = "tier_pid"),
      inverseJoinColumns = @JoinColumn(name = "tag_pid"))
  @AuditJoinTable(name = "tier_tag_aud")
  @OrderColumn(name = "tag_order")
  @JsonIgnoreProperties(
      value = {"site"},
      allowSetters = true)
  @EqualsAndHashCode.Include
  private List<Tag> tags = new ArrayList<>();

  @Column(name = "autogenerated")
  private boolean isAutogenerated;

  @Column(name = "tier_type", nullable = false)
  @Enumerated(EnumType.ORDINAL)
  @EqualsAndHashCode.Include
  private TierType tierType = TierType.WATERFALL;

  /*
   * this map is used for persistence, but not passed to flex, due to limitations of flex/java mapping
   * The variable needs to be called 'weight', because that is the name of the field in the table
   */
  @ElementCollection(fetch = FetchType.EAGER)
  @CollectionTable(name = "tier_tag_weight", joinColumns = @JoinColumn(name = "tier_pid"))
  @MapKeyColumn(name = "tag_pid")
  private Map<Long, Double> weight = new HashMap<>();

  /*
   * This is map is solely for flex/java marshaling. Flex requires maps that have String keys and cannot start with a number
   * So we are appending an underscore to each key
   */
  @Transient @JsonIgnore private Map<String, Double> weightsMap = new HashMap<>();

  public Map<String, Double> getWeightsMap() {
    if (null == weightsMap) {
      weightsMap = new HashMap<>();
    }
    weightsMap.clear();
    for (Map.Entry<Long, Double> entry : weight.entrySet()) {
      String key = this.convertPidToWeightKey(entry.getKey());
      if (null != key) {
        weightsMap.put(key, entry.getValue());
      }
    }
    return weightsMap;
  }

  public void setWeightsMap(Map<String, Double> map) {
    weightsMap = map;
    for (Map.Entry<String, Double> entry : weightsMap.entrySet()) {
      Long convertedPid = convertWeightKeyToPid(entry.getKey());
      if (null != convertedPid) {
        weight.put(convertedPid, entry.getValue());
      }
    }
  }

  public Tier() {}

  public Tier(int level) {
    this.level = level;
  }

  public void addTag(Tag t) {
    tags.add(t);
  }

  public void removeTag(Tag t) {
    tags.remove(t);
    weight.remove(t.getPid());
  }

  protected Long convertWeightKeyToPid(String key) {
    Long returnKey = null;
    if (StringUtils.isNotBlank(key)) {
      if (key.startsWith(WEIGHTS_MAP_KEY_PREFIX)) {
        String pidString = key.substring(1);
        try {
          Long pidLong = Long.parseLong(pidString);
          returnKey = pidLong;
        } catch (NumberFormatException e) {
          logger.warn(String.format("could not convert key : %s to a Long", pidString));
        }
      } else {
        logger.debug("input key does not start with required prefix");
      }
    }
    return returnKey;
  }

  protected String convertPidToWeightKey(Long pid) {
    return String.format("%s%s", WEIGHTS_MAP_KEY_PREFIX, pid);
  }

  public void addTagWeight(Long tagPid, Double inputWeight) {
    if (null == tagPid) {
      logger.warn("trying to set weight for null tagPid");
    } else {
      if (null == weight) {
        weight = new HashMap<>();
      }
      weight.put(tagPid, inputWeight);
    }
  }

  public boolean isAutogenerated() {
    return isAutogenerated;
  }

  public void setTags(List<Tag> inputTags) {
    if (null != tags) {
      tags.clear();
      tags.addAll(inputTags);
    } else {
      tags = inputTags;
    }
  }

  public List<Tag> getTags() {
    Tag.Deployment de = new Tag.Deployment();
    de.setPosition(positionName);
    de.setTier(level);
    for (Tag tag : tags) {
      tag.addToDeployments(de);
    }
    return tags;
  }

  public void setWeight(Map<Long, Double> inputWeights) {
    if (null != weight) {
      weight.clear();
      if (null != inputWeights) {
        weight.putAll(inputWeights);
      }
    } else {
      weight = inputWeights;
    }
  }

  public Map<Long, Double> getWeight() {
    return weight;
  }

  public void clearWeights() {
    if (null == weight) {
      weight = new HashMap<>();
    } else {
      weight.clear();
    }
  }
}
